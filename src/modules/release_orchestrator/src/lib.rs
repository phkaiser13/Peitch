/* Copyright (C) 2025 Pedro Henrique / phkaiser13
* File: src/modules/release_orchestrator/src/lib.rs
*
* This file has been refactored to be the FFI entry point for a CRD-based
* release orchestration. It parses incoming JSON payloads and dispatches to
* handlers that perform CRUD operations on PhgitRelease custom resources.
*
* SPDX-License-Identifier: Apache-2.0 */

pub mod config;
pub mod crd;

use anyhow::{anyhow, Context, Result};
use config::{IdConfig, PlanConfig, RolloutPayload, StartConfig, StatusConfig};
use crd::{
    Analysis, CanaryStep, CanaryStrategy, Metric, PhgitRelease, PhgitReleaseSpec, PhgitReleaseStatus,
    Strategy,
};
use kube::{
    api::{Api, ObjectMeta, Patch, PatchParams, PostParams},
    Client,
};
use prost::Message;
use std::ffi::{c_char, CStr};
use std::os::raw::c_int;
use std::panic;

// This struct mirrors the ErrorPayload message from rpc_data.proto.
// In a real build system, this would be generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorPayload {
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
}

const RELEASE_NAMESPACE: &str = "ph-releases";

async fn handle_start(config: StartConfig) -> Result<()> {
    println!("🚀 Starting new release for app: {}", config.app);

    let client = Client::try_default()
        .await
        .context("Failed to create Kubernetes client")?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);

    // --- Build a "dumb" Canary Strategy ---
    // All parsing logic is moved to the operator. This module just passes the raw strings.
    let canary_strategy = CanaryStrategy {
        steps_str: config.steps,
        metric_str: config.metric,
        analysis_window_str: config.analysis_window,
        auto_promote: true, // Defaulting to true for now
        steps: vec![], // This will be populated by the controller
        analysis: None, // This will be populated by the controller
    };

    let strategy = Strategy {
        type_: "Canary".to_string(),
        canary: Some(canary_strategy),
        blue_green: None,
    };

    // --- Construct the PhgitRelease Resource ---
    let release = PhgitRelease {
        metadata: ObjectMeta {
            name: Some(config.app.clone()),
            ..Default::default()
        },
        spec: PhgitReleaseSpec {
            app_name: config.app.clone(),
            version: config.image, // Using image as version for now
            strategy,
        },
        status: Some(PhgitReleaseStatus {
            phase: Some("Progressing".to_string()),
            ..Default::default()
        }),
    };

    // --- Create the Resource in Kubernetes ---
    releases
        .create(&PostParams::default(), &release)
        .await
        .context(format!("Failed to create PhgitRelease resource for app '{}'", config.app))?;

    println!("✅ PhgitRelease resource '{}' created successfully. The operator will now process the rollout.", config.app);
    Ok(())
}

async fn handle_status(config: StatusConfig) -> Result<()> {
    println!("🔎 Getting status for release: {}", config.id);
    // Implementation would fetch the PhgitRelease resource and print its status
    Ok(())
}

async fn handle_promote(config: IdConfig) -> Result<()> {
    println!("👍 Promoting release: {}", config.id);
    let client = Client::try_default().await?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);
    let patch = serde_json::json!({
        "status": {
            "state": "Promoted"
        }
    });
    releases.patch_status(&config.id, &PatchParams::default(), &Patch::Merge(&patch)).await?;
    println!("✅ Release '{}' promoted.", config.id);
    Ok(())
}

async fn handle_rollback(config: IdConfig) -> Result<()> {
    println!("⏪ Rolling back release: {}", config.id);
    let client = Client::try_default().await.context("Failed to create Kubernetes client")?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);

    let patch = if let Some(revision) = config.to_revision {
        println!("... to revision {}", revision);
        serde_json::json!({
            "status": {
                "phase": "RollingBack",
                "rollbackTo": revision
            }
        })
    } else {
        println!("... to previous version");
        serde_json::json!({
            "status": {
                "phase": "RollingBack"
            }
        })
    };

    releases.patch_status(&config.id, &PatchParams::default(), &Patch::Merge(&patch))
        .await
        .context(format!("Failed to patch status for rollback on PhgitRelease '{}'", config.id))?;

    println!("✅ PhgitRelease '{}' status patched for rollback.", config.id);
    Ok(())
}

async fn handle_plan(_config: PlanConfig) -> Result<()> {
    println!("📝 'plan' action is not fully implemented. It would show preflight checks here.");
    Ok(())
}


#[no_mangle]
pub extern "C" fn run_release_orchestrator(
    config_json: *const c_char,
    error_buf: *mut u8,
    error_buf_len: usize,
) -> c_int {
    let result = panic::catch_unwind(|| {
        if config_json.is_null() {
            return -1;
        }
        let c_str = unsafe { CStr::from_ptr(config_json) };
        let rust_str = c_str.to_str().unwrap();
        let config: RolloutPayload = serde_json::from_str(rust_str).unwrap();

        let runtime = tokio::runtime::Builder::new_multi_thread().enable_all().build().unwrap();
        
        let exec_result = runtime.block_on(async {
            match config {
                RolloutPayload::Start(cfg) => handle_start(cfg).await,
                RolloutPayload::Status(cfg) => handle_status(cfg).await,
                RolloutPayload::Promote(cfg) => handle_promote(cfg).await,
                RolloutPayload::Rollback(cfg) => handle_rollback(cfg).await,
                RolloutPayload::Plan(cfg) => handle_plan(cfg).await,
            }
        });

        match exec_result {
            Ok(_) => 0,
            Err(e) => {
                // Create a structured error payload
                let error_payload = ErrorPayload {
                    code: "ReleaseFailed".to_string(),
                    message: format!("{}", e), // High-level message from anyhow
                    details: format!("{:?}", e), // Full error chain for details
                };

                // Serialize the payload
                let mut buf = Vec::new();
                if error_payload.encode(&mut buf).is_ok() {
                    // Copy to the C buffer if it's large enough
                    let len_to_copy = std::cmp::min(buf.len(), error_buf_len);
                    if len_to_copy > 0 {
                        unsafe {
                            std::ptr::copy_nonoverlapping(buf.as_ptr(), error_buf, len_to_copy);
                        }
                    }
                }
                
                -4 // Return error code
            }
        }
    });

    result.unwrap_or(-5)
}