/* Copyright (C) 2025 Pedro Henrique / phkaiser13
* File: src/modules/release_orchestrator/src/lib.rs
*
* This file has been refactored to be the FFI entry point for a CRD-based
* release orchestration. It parses incoming JSON payloads and dispatches to
* handlers that perform CRUD operations on PhgitRelease custom resources.
*
* SPDX-License-Identifier: Apache-2.0 */

pub mod config;
pub mod crd;

use anyhow::{anyhow, Context, Result};
use chrono::Utc;
use config::{IdConfig, PlanConfig, RolloutPayload, StartConfig, StatusConfig};
use crd::{PhgitRelease, PhgitReleaseSpec, PhgitReleaseStatus, Artifact, Provenance};
use kube::{
    api::{Api, DeleteParams, ObjectMeta, Patch, PatchParams, PostParams},
    Client,
};
use signature_verifier::verify_image_signature;
use std::ffi::{c_char, CStr};
use std::panic;
use std::os::raw::c_int;
use prost::Message;

// This struct mirrors the ErrorPayload message from rpc_data.proto.
// In a real build system, this would be generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorPayload {
    #[prost(string, tag="1")]
    pub code: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub details: ::prost::alloc::string::String,
}

const RELEASE_NAMESPACE: &str = "ph-releases";

async fn handle_start(config: StartConfig) -> Result<()> {
    println!("ğŸš€ Starting new release for app: {}", config.app);

    // --- Signature Verification Step ---
    let (signer, verified) = if config.skip_sig_check {
        println!("âš ï¸ WARNING: Signature verification has been skipped for image '{}'.", config.image);
        ("skipped".to_string(), false)
    } else {
        let public_key = config.public_key
            .ok_or_else(|| anyhow!("Signature verification is enabled, but no public key was provided."))?;

        match verify_image_signature(&config.image, &public_key).await {
            Ok(signer) => (signer, true),
            Err(e) => {
                // The error from verify_image_signature is already detailed.
                return Err(e).context("Image signature verification failed");
            }
        }
    };

    let client = Client::try_default().await?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);

    let release = PhgitRelease {
        metadata: ObjectMeta {
            name: Some(config.app.clone()),
            ..Default::default()
        },
        spec: PhgitReleaseSpec {
            name: config.app.clone(),
            source: "TBD".to_string(),
            artifacts: vec![Artifact { image: config.image, sbom: "".to_string() }],
            strategy: config.strategy,
        },
        status: Some(PhgitReleaseStatus {
            state: "InProgress".to_string(),
            provenance: Provenance {
                signer,
                verified,
                verification_timestamp: Utc::now().to_rfc3339(),
            },
            ..Default::default()
        }),
    };

    releases.create(&PostParams::default(), &release).await?;
    println!("âœ… PhgitRelease resource '{}' created.", config.app);
    Ok(())
}

async fn handle_status(config: StatusConfig) -> Result<()> {
    println!("ğŸ” Getting status for release: {}", config.id);
    // Implementation would fetch the PhgitRelease resource and print its status
    Ok(())
}

async fn handle_promote(config: IdConfig) -> Result<()> {
    println!("ğŸ‘ Promoting release: {}", config.id);
    let client = Client::try_default().await?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);
    let patch = serde_json::json!({
        "status": {
            "state": "Promoted"
        }
    });
    releases.patch_status(&config.id, &PatchParams::default(), &Patch::Merge(&patch)).await?;
    println!("âœ… Release '{}' promoted.", config.id);
    Ok(())
}

async fn handle_rollback(config: IdConfig) -> Result<()> {
    println!("âª Rolling back release: {}", config.id);
     let client = Client::try_default().await?;
    let releases: Api<PhgitRelease> = Api::namespaced(client, RELEASE_NAMESPACE);
    let patch = serde_json::json!({
        "status": {
            "state": "RolledBack"
        }
    });
    releases.patch_status(&config.id, &PatchParams::default(), &Patch::Merge(&patch)).await?;
    println!("âœ… Release '{}' rolled back.", config.id);
    Ok(())
}

async fn handle_plan(_config: PlanConfig) -> Result<()> {
    println!("ğŸ“ 'plan' action is not fully implemented. It would show preflight checks here.");
    Ok(())
}


#[no_mangle]
pub extern "C" fn run_release_orchestrator(
    config_json: *const c_char,
    error_buf: *mut u8,
    error_buf_len: usize,
) -> c_int {
    let result = panic::catch_unwind(|| {
        if config_json.is_null() {
            return -1;
        }
        let c_str = unsafe { CStr::from_ptr(config_json) };
        let rust_str = c_str.to_str().unwrap();
        let config: RolloutPayload = serde_json::from_str(rust_str).unwrap();

        let runtime = tokio::runtime::Builder::new_multi_thread().enable_all().build().unwrap();
        
        let exec_result = runtime.block_on(async {
            match config {
                RolloutPayload::Start(cfg) => handle_start(cfg).await,
                RolloutPayload::Status(cfg) => handle_status(cfg).await,
                RolloutPayload::Promote(cfg) => handle_promote(cfg).await,
                RolloutPayload::Rollback(cfg) => handle_rollback(cfg).await,
                RolloutPayload::Plan(cfg) => handle_plan(cfg).await,
            }
        });

        match exec_result {
            Ok(_) => 0,
            Err(e) => {
                // Create a structured error payload
                let error_payload = ErrorPayload {
                    code: "ReleaseFailed".to_string(),
                    message: format!("{}", e), // High-level message from anyhow
                    details: format!("{:?}", e), // Full error chain for details
                };

                // Serialize the payload
                let mut buf = Vec::new();
                if error_payload.encode(&mut buf).is_ok() {
                    // Copy to the C buffer if it's large enough
                    let len_to_copy = std::cmp::min(buf.len(), error_buf_len);
                    if len_to_copy > 0 {
                        unsafe {
                            std::ptr::copy_nonoverlapping(buf.as_ptr(), error_buf, len_to_copy);
                        }
                    }
                }
                
                -4 // Return error code
            }
        }
    });

    result.unwrap_or(-5)
}